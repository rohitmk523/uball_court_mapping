<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UWB Tag Viewer - Working Version</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .header h1 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }

        canvas {
            background-color: #2a2a2a;
            border-radius: 4px;
            display: block;
            margin: 0 auto 20px auto;
        }

        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }

        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        button:hover {
            background: #45a049;
        }

        .slider-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        input[type="range"] {
            width: 300px;
        }

        .stats {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸŽ¯ UWB Tag Viewer</h1>
            <p><strong>Court Dimensions:</strong> 2460cm x 1730cm</p>
        </div>

        <canvas id="canvas" width="1400" height="700"></canvas>

        <div class="controls">
            <button id="playBtn" onclick="togglePlay()">Play</button>

            <div style="background: #333; padding: 10px 20px; border-radius: 4px;">
                <div style="font-size: 1.5em; font-weight: bold; color: #4CAF50;">
                    Time: <span id="timeDisplay">0.00s</span> / <span id="totalTime">0.00s</span>
                </div>
                <div style="font-size: 0.9em; color: #aaa; margin-top: 5px;">
                    Frame: <span id="frameDisplay">0</span> / <span id="totalFrames">0</span>
                </div>
            </div>

            <div class="slider-group" style="flex-grow: 1;">
                <input type="range" id="frameSlider" min="0" max="100" value="0" oninput="onFrameChange()">
            </div>

            <select id="speedSelect" onchange="onSpeedChange()">
                <option value="1">1x</option>
                <option value="2">2x</option>
                <option value="5">5x</option>
                <option value="10">10x</option>
            </select>
        </div>

        <div class="stats" id="stats">Loading...</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // State
        let tagDataMap = {}; // tag_id -> {positions: [{x, y, timestamp}, ...]}
        let allTagIds = [];
        let isPlaying = false;
        let currentFrame = 0;
        let maxFrames = 0;
        let playbackSpeed = 1.0;
        let animationId = null;
        let lastFrameTime = 0;
        let courtGeometry = null;

        // Video FPS
        const VIDEO_FPS = 29.97;

        // Court dimensions (from DXF - in cm) - HORIZONTAL orientation
        const COURT_WIDTH = 2460.2;  // baseline to baseline (horizontal)
        const COURT_HEIGHT = 1730.8; // sideline to sideline (vertical)
        const PADDING = 50;
        const SCALE = (canvas.width - PADDING * 2) / COURT_WIDTH;

        console.log('[TAG_VIEWER] Initializing...');
        console.log('[TAG_VIEWER] Canvas:', canvas.width, 'x', canvas.height);
        console.log('[TAG_VIEWER] Scale:', SCALE);

        // Transform court coordinates to canvas coordinates (with FULL bounds support + centering)
        function worldToScreen(x, y) {
            if (!courtBounds || !actualScale) {
                // Fallback to old method if bounds not loaded yet
                const sx = (x * SCALE) + PADDING;
                const sy = canvas.height - ((y * SCALE) + PADDING);
                return {x: sx, y: sy};
            }

            // Calculate court dimensions and centering offsets
            const courtWidth = courtBounds.max_x - courtBounds.min_x;
            const courtHeight = courtBounds.max_y - courtBounds.min_y;
            const scaledWidth = courtWidth * actualScale;
            const scaledHeight = courtHeight * actualScale;
            const offsetX = (canvas.width - scaledWidth) / 2;
            const offsetY = (canvas.height - scaledHeight) / 2;

            // Translate coordinates to account for negative min values, scale, and center
            const sx = ((x - courtBounds.min_x) * actualScale) + offsetX;
            const sy = canvas.height - (((y - courtBounds.min_y) * actualScale) + offsetY);
            return {x: sx, y: sy};
        }

        // Variables to store actual court bounds
        let courtBounds = null;
        let actualScale = null;

        // Load court geometry
        async function loadCourtGeometry() {
            try {
                console.log('[TAG_VIEWER] Loading court geometry...');
                const response = await fetch('/api/court/geometry');
                courtGeometry = await response.json();
                courtBounds = courtGeometry.bounds;

                // Calculate actual court dimensions from bounds
                const actualWidth = courtBounds.max_x - courtBounds.min_x;
                const actualHeight = courtBounds.max_y - courtBounds.min_y;

                // Calculate scale to fit FULL court with padding
                const scaleX = (canvas.width - PADDING * 2) / actualWidth;
                const scaleY = (canvas.height - PADDING * 2) / actualHeight;
                actualScale = Math.min(scaleX, scaleY);

                console.log('[TAG_VIEWER] Court bounds:', courtBounds);
                console.log('[TAG_VIEWER] Actual dimensions:', actualWidth, 'x', actualHeight);
                console.log('[TAG_VIEWER] Actual scale:', actualScale);

                return true;
            } catch (error) {
                console.error('[TAG_VIEWER] Error loading court geometry:', error);
                return false;
            }
        }

        // Load all tag data
        async function loadTagData() {
            try {
                console.log('[TAG_VIEWER] Loading tag list...');
                const listResponse = await fetch('/api/tags/list');
                allTagIds = await listResponse.json();
                console.log('[TAG_VIEWER] Found tags:', allTagIds);

                // Load data for each tag
                for (const tagId of allTagIds) {
                    console.log('[TAG_VIEWER] Loading tag', tagId);
                    const response = await fetch(`/api/tags/${tagId}`);
                    const data = await response.json();
                    tagDataMap[tagId] = data;
                }

                // Find maximum frame count
                maxFrames = 0;
                for (const tagId in tagDataMap) {
                    const positions = tagDataMap[tagId].positions || [];
                    maxFrames = Math.max(maxFrames, positions.length);
                }

                console.log('[TAG_VIEWER] Max frames:', maxFrames);
                document.getElementById('frameSlider').max = maxFrames - 1;
                document.getElementById('totalFrames').textContent = maxFrames;

                return true;
            } catch (error) {
                console.error('[TAG_VIEWER] Error loading tag data:', error);
                return false;
            }
        }

        // Draw basketball court
        function drawCourt() {
            if (!courtGeometry || !courtBounds) {
                console.log('[TAG_VIEWER] Waiting for court geometry and bounds...');
                return;
            }

            ctx.strokeStyle = '#FFFFFF';  // Bright WHITE for clarity
            ctx.lineWidth = 2;  // Normal thickness (clearer, not thicker)

            // Draw polylines
            if (courtGeometry.polylines) {
                courtGeometry.polylines.forEach(polyline => {
                    if (polyline.length < 2) return;
                    ctx.beginPath();
                    const start = worldToScreen(polyline[0][0], polyline[0][1]);
                    ctx.moveTo(start.x, start.y);
                    for (let i = 1; i < polyline.length; i++) {
                        const point = worldToScreen(polyline[i][0], polyline[i][1]);
                        ctx.lineTo(point.x, point.y);
                    }
                    ctx.closePath();  // Close the polyline to draw the final line back to start
                    ctx.stroke();
                });
            }

            // Draw lines
            if (courtGeometry.lines) {
                courtGeometry.lines.forEach(line => {
                    const start = worldToScreen(line[0][0], line[0][1]);
                    const end = worldToScreen(line[1][0], line[1][1]);
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                });
            }

            // Draw circles (skip large 3-point arcs)
            if (courtGeometry.circles) {
                courtGeometry.circles.forEach(circle => {
                    const radius = circle[1]; // radius in cm
                    // Skip circles larger than 300cm (3-point arcs)
                    if (radius > 300) return;

                    const center = worldToScreen(circle[0][0], circle[0][1]);
                    const scaledRadius = radius * (actualScale || SCALE);
                    ctx.beginPath();
                    ctx.arc(center.x, center.y, scaledRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                });
            }
        }

        // Get tag color
        function getTagColor(tagId) {
            const hue = (tagId * 137.5) % 360;
            return `hsl(${hue}, 70%, 50%)`;
        }

        // Draw tags at current frame
        function drawTags() {
            let tagsDrawn = 0;

            for (const tagId of allTagIds) {
                const tagData = tagDataMap[tagId];
                if (!tagData || !tagData.positions) continue;

                const positions = tagData.positions;
                if (currentFrame >= positions.length) continue;

                const pos = positions[currentFrame];
                const screen = worldToScreen(pos.x, pos.y);
                const color = getTagColor(tagId);

                // Draw tag as circle with outline
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(screen.x, screen.y, 10, 0, 2 * Math.PI);
                ctx.fill();

                // White outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw tag ID
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(tagId, screen.x + 15, screen.y + 5);

                tagsDrawn++;
            }

            return tagsDrawn;
        }

        // Draw current frame
        function drawFrame() {
            // Clear canvas
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw court
            drawCourt();

            // Draw tags
            const tagsDrawn = drawTags();

            // Calculate time in seconds
            const currentTime = currentFrame / VIDEO_FPS;
            const totalTime = maxFrames / VIDEO_FPS;

            // Update UI
            document.getElementById('frameDisplay').textContent = currentFrame;
            document.getElementById('totalFrames').textContent = maxFrames;
            document.getElementById('timeDisplay').textContent = currentTime.toFixed(2) + 's';
            document.getElementById('totalTime').textContent = totalTime.toFixed(2) + 's';

            document.getElementById('stats').innerHTML = `
                <strong>Time:</strong> ${currentTime.toFixed(2)}s / ${totalTime.toFixed(2)}s<br>
                <strong>Frame:</strong> ${currentFrame} / ${maxFrames}<br>
                <strong>Tags visible:</strong> ${tagsDrawn} / ${allTagIds.length}<br>
                <strong>Playback speed:</strong> ${playbackSpeed}x
            `;
        }

        // Playback controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').textContent = isPlaying ? 'Pause' : 'Play';

            if (isPlaying) {
                lastFrameTime = performance.now();
                animate();
            } else {
                cancelAnimationFrame(animationId);
            }
        }

        function animate(currentTime) {
            if (!isPlaying) return;

            const elapsed = currentTime - lastFrameTime;
            const frameDuration = (1000 / VIDEO_FPS) / playbackSpeed; // 29.97 FPS

            if (elapsed > frameDuration) {
                currentFrame++;
                if (currentFrame >= maxFrames) {
                    currentFrame = 0;
                }

                document.getElementById('frameSlider').value = currentFrame;
                drawFrame();
                lastFrameTime = currentTime;
            }

            animationId = requestAnimationFrame(animate);
        }

        function onFrameChange() {
            currentFrame = parseInt(document.getElementById('frameSlider').value);
            drawFrame();
        }

        function onSpeedChange() {
            playbackSpeed = parseFloat(document.getElementById('speedSelect').value);
        }

        // Initialize
        async function init() {
            console.log('[TAG_VIEWER] Starting initialization...');
            document.getElementById('stats').textContent = 'Loading data...';

            const courtLoaded = await loadCourtGeometry();
            if (!courtLoaded) {
                document.getElementById('stats').textContent = 'Error loading court geometry';
                return;
            }

            const tagsLoaded = await loadTagData();
            if (!tagsLoaded) {
                document.getElementById('stats').textContent = 'Error loading tag data';
                return;
            }

            console.log('[TAG_VIEWER] Initialization complete, drawing first frame...');
            drawFrame();
        }

        // Start when page loads
        init();
    </script>
</body>
</html>
